{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useNavigation = useNavigation;\nexports.useNavigationParam = useNavigationParam;\nexports.useNavigationState = useNavigationState;\nexports.useNavigationKey = useNavigationKey;\nexports.useNavigationEvents = useNavigationEvents;\nexports.useFocusState = useFocusState;\nexports.useIsFocused = exports.useFocusEffect = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _react = require(\"react\");\n\nvar _reactNavigation = require(\"react-navigation\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    keys.push.apply(keys, Object.getOwnPropertySymbols(object));\n  }\n\n  if (enumerableOnly) keys = keys.filter(function (sym) {\n    return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n  });\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction useNavigation() {\n  var navigation = (0, _react.useContext)(_reactNavigation.NavigationContext);\n\n  if (!navigation) {\n    throw new Error(\"react-navigation hooks require a navigation context but it couldn't be found. \" + \"Make sure you didn't forget to create and render the react-navigation app container. \" + 'If you need to access an optional navigation object, you can useContext(NavigationContext), which may return');\n  }\n\n  return navigation;\n}\n\nfunction useNavigationParam(paramName) {\n  return useNavigation().getParam(paramName);\n}\n\nfunction useNavigationState() {\n  return useNavigation().state;\n}\n\nfunction useNavigationKey() {\n  return useNavigation().state.key;\n}\n\nvar useGetter = function useGetter(value) {\n  var ref = (0, _react.useRef)(value);\n  (0, _react.useLayoutEffect)(function () {\n    ref.current = value;\n  });\n  return (0, _react.useCallback)(function () {\n    return ref.current;\n  }, [ref]);\n};\n\nfunction useNavigationEvents(callback) {\n  var navigation = useNavigation();\n  var getLatestCallback = useGetter(callback);\n  (0, _react.useLayoutEffect)(function () {\n    var subscribedCallback = function subscribedCallback(event) {\n      var latestCallback = getLatestCallback();\n      latestCallback(event);\n    };\n\n    var subs = [navigation.addListener('action', subscribedCallback), navigation.addListener('willFocus', subscribedCallback), navigation.addListener('didFocus', subscribedCallback), navigation.addListener('willBlur', subscribedCallback), navigation.addListener('didBlur', subscribedCallback)];\n    return function () {\n      subs.forEach(function (sub) {\n        return sub.remove();\n      });\n    };\n  }, [navigation.state.key]);\n}\n\nvar emptyFocusState = {\n  isFocused: false,\n  isBlurring: false,\n  isBlurred: false,\n  isFocusing: false\n};\n\nvar didFocusState = _objectSpread({}, emptyFocusState, {\n  isFocused: true\n});\n\nvar willBlurState = _objectSpread({}, emptyFocusState, {\n  isBlurring: true\n});\n\nvar didBlurState = _objectSpread({}, emptyFocusState, {\n  isBlurred: true\n});\n\nvar willFocusState = _objectSpread({}, emptyFocusState, {\n  isFocusing: true\n});\n\nfunction nextFocusState(eventName, currentState) {\n  switch (eventName) {\n    case 'willFocus':\n      return _objectSpread({}, willFocusState, {\n        isFocused: currentState.isFocused\n      });\n\n    case 'didFocus':\n      return didFocusState;\n\n    case 'willBlur':\n      return willBlurState;\n\n    case 'didBlur':\n      return didBlurState;\n\n    default:\n      return currentState;\n  }\n}\n\nfunction useFocusState() {\n  var navigation = useNavigation();\n\n  var _useState = (0, _react.useState)(function () {\n    return navigation.isFocused() ? didFocusState : didBlurState;\n  }),\n      _useState2 = (0, _slicedToArray2.default)(_useState, 2),\n      focusState = _useState2[0],\n      setFocusState = _useState2[1];\n\n  useNavigationEvents(function (e) {\n    setFocusState(function (currentFocusState) {\n      return nextFocusState(e.type, currentFocusState);\n    });\n  });\n  return focusState;\n}\n\nvar useFocusEffect = function useFocusEffect(callback) {\n  var navigation = useNavigation();\n  (0, _react.useEffect)(function () {\n    var isFocused = false;\n    var cleanup;\n\n    if (navigation.isFocused()) {\n      cleanup = callback();\n      isFocused = true;\n    }\n\n    var focusSubscription = navigation.addListener('willFocus', function () {\n      if (isFocused) {\n        return;\n      }\n\n      cleanup && cleanup();\n      cleanup = callback();\n      isFocused = true;\n    });\n    var blurSubscription = navigation.addListener('willBlur', function () {\n      cleanup && cleanup();\n      cleanup = undefined;\n      isFocused = false;\n    });\n    return function () {\n      cleanup && cleanup();\n      focusSubscription.remove();\n      blurSubscription.remove();\n    };\n  }, [callback, navigation]);\n};\n\nexports.useFocusEffect = useFocusEffect;\n\nvar useIsFocused = function useIsFocused() {\n  var navigation = useNavigation();\n  var getNavigation = useGetter(navigation);\n\n  var _useState3 = (0, _react.useState)(navigation.isFocused),\n      _useState4 = (0, _slicedToArray2.default)(_useState3, 2),\n      focused = _useState4[0],\n      setFocused = _useState4[1];\n\n  (0, _react.useEffect)(function () {\n    var nav = getNavigation();\n    var focusSubscription = nav.addListener('willFocus', function () {\n      return setFocused(true);\n    });\n    var blurSubscription = nav.addListener('willBlur', function () {\n      return setFocused(false);\n    });\n    return function () {\n      focusSubscription.remove();\n      blurSubscription.remove();\n    };\n  }, [getNavigation]);\n  return focused;\n};\n\nexports.useIsFocused = useIsFocused;","map":{"version":3,"sources":["Hooks.ts"],"names":["navigation","useContext","useNavigation","useGetter","ref","useRef","useLayoutEffect","useCallback","getLatestCallback","subscribedCallback","latestCallback","subs","sub","emptyFocusState","isFocused","isBlurring","isBlurred","isFocusing","didFocusState","willBlurState","didBlurState","willFocusState","currentState","focusState","setFocusState","useState","useNavigationEvents","nextFocusState","e","useFocusEffect","useEffect","cleanup","callback","focusSubscription","blurSubscription","useIsFocused","getNavigation","focused","setFocused","nav"],"mappings":"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","sourcesContent":["import {\n  useState,\n  useContext,\n  useEffect,\n  useLayoutEffect,\n  useRef,\n  useCallback,\n} from 'react';\n\nimport {\n  NavigationContext,\n  NavigationScreenProp,\n  NavigationRoute,\n  NavigationParams,\n  NavigationEventCallback,\n  NavigationEventPayload,\n  EventType,\n} from 'react-navigation';\n\nexport function useNavigation<S>(): NavigationScreenProp<S & NavigationRoute> {\n  const navigation = useContext(NavigationContext) as any; // TODO typing?\n  if (!navigation) {\n    throw new Error(\n      \"react-navigation hooks require a navigation context but it couldn't be found. \" +\n        \"Make sure you didn't forget to create and render the react-navigation app container. \" +\n        'If you need to access an optional navigation object, you can useContext(NavigationContext), which may return'\n    );\n  }\n  return navigation;\n}\n\nexport function useNavigationParam<T extends keyof NavigationParams>(\n  paramName: T\n) {\n  return useNavigation().getParam(paramName);\n}\n\nexport function useNavigationState() {\n  return useNavigation().state;\n}\n\nexport function useNavigationKey() {\n  return useNavigation().state.key;\n}\n\n// Useful to access the latest user-provided value\nconst useGetter = <S>(value: S): (() => S) => {\n  const ref = useRef(value);\n  useLayoutEffect(() => {\n    ref.current = value;\n  });\n  return useCallback(() => ref.current, [ref]);\n};\n\nexport function useNavigationEvents(callback: NavigationEventCallback) {\n  const navigation = useNavigation();\n\n  // Closure might change over time and capture some variables\n  // It's important to fire the latest closure provided by the user\n  const getLatestCallback = useGetter(callback);\n\n  // It's important to useLayoutEffect because we want to ensure we subscribe synchronously to the mounting\n  // of the component, similarly to what would happen if we did use componentDidMount\n  // (that we use in <NavigationEvents/>)\n  // When mounting/focusing a new screen and subscribing to focus, the focus event should be fired\n  // It wouldn't fire if we did subscribe with useEffect()\n  useLayoutEffect(() => {\n    const subscribedCallback: NavigationEventCallback = event => {\n      const latestCallback = getLatestCallback();\n      latestCallback(event);\n    };\n\n    const subs = [\n      // TODO should we remove \"action\" here? it's not in the published typedefs\n      navigation.addListener('action' as any, subscribedCallback),\n      navigation.addListener('willFocus', subscribedCallback),\n      navigation.addListener('didFocus', subscribedCallback),\n      navigation.addListener('willBlur', subscribedCallback),\n      navigation.addListener('didBlur', subscribedCallback),\n    ];\n    return () => {\n      subs.forEach(sub => sub.remove());\n    };\n  }, [navigation.state.key]);\n}\n\nexport interface FocusState {\n  isFocused: boolean;\n  isBlurring: boolean;\n  isBlurred: boolean;\n  isFocusing: boolean;\n}\n\nconst emptyFocusState: FocusState = {\n  isFocused: false,\n  isBlurring: false,\n  isBlurred: false,\n  isFocusing: false,\n};\nconst didFocusState: FocusState = { ...emptyFocusState, isFocused: true };\nconst willBlurState: FocusState = { ...emptyFocusState, isBlurring: true };\nconst didBlurState: FocusState = { ...emptyFocusState, isBlurred: true };\nconst willFocusState: FocusState = { ...emptyFocusState, isFocusing: true };\n\nfunction nextFocusState(\n  eventName: EventType,\n  currentState: FocusState\n): FocusState {\n  switch (eventName) {\n    case 'willFocus':\n      return {\n        ...willFocusState,\n        // /!\\ willFocus will fire on screen mount, while the screen is already marked as focused.\n        // In case of a new screen mounted/focused, we want to avoid a isFocused = true => false => true transition\n        // So we don't put the \"false\" here and ensure the attribute remains as before\n        // Currently I think the behavior of the event system on mount is not very well specified\n        // See also https://twitter.com/sebastienlorber/status/1166986080966578176\n        isFocused: currentState.isFocused,\n      };\n    case 'didFocus':\n      return didFocusState;\n    case 'willBlur':\n      return willBlurState;\n    case 'didBlur':\n      return didBlurState;\n    default:\n      // preserve current state for other events (\"action\"?)\n      return currentState;\n  }\n}\n\nexport function useFocusState() {\n  const navigation = useNavigation();\n\n  const [focusState, setFocusState] = useState<FocusState>(() => {\n    return navigation.isFocused() ? didFocusState : didBlurState;\n  });\n\n  useNavigationEvents((e: NavigationEventPayload) => {\n    setFocusState(currentFocusState =>\n      nextFocusState(e.type, currentFocusState)\n    );\n  });\n\n  return focusState;\n}\n\ntype EffectCallback = (() => void) | (() => () => void);\n\n// Inspired by same hook from react-navigation v5\n// See https://github.com/react-navigation/hooks/issues/39#issuecomment-534694135\nexport const useFocusEffect = (callback: EffectCallback) => {\n  const navigation = useNavigation();\n\n  useEffect(() => {\n    let isFocused = false;\n    let cleanup: (() => void) | void;\n\n    if (navigation.isFocused()) {\n      cleanup = callback();\n      isFocused = true;\n    }\n\n    const focusSubscription = navigation.addListener('willFocus', () => {\n      // If callback was already called for focus, avoid calling it again\n      // The focus event may also fire on intial render, so we guard against runing the effect twice\n      if (isFocused) {\n        return;\n      }\n\n      cleanup && cleanup();\n      cleanup = callback();\n      isFocused = true;\n    });\n\n    const blurSubscription = navigation.addListener('willBlur', () => {\n      cleanup && cleanup();\n      cleanup = undefined;\n      isFocused = false;\n    });\n\n    return () => {\n      cleanup && cleanup();\n      focusSubscription.remove();\n      blurSubscription.remove();\n    };\n  }, [callback, navigation]);\n};\n\nexport const useIsFocused = () => {\n  const navigation = useNavigation();\n  const getNavigation = useGetter(navigation);\n  const [focused, setFocused] = useState(navigation.isFocused);\n\n  useEffect(() => {\n    const nav = getNavigation();\n    const focusSubscription = nav.addListener('willFocus', () =>\n      setFocused(true)\n    );\n    const blurSubscription = nav.addListener('willBlur', () =>\n      setFocused(false)\n    );\n    return () => {\n      focusSubscription.remove();\n      blurSubscription.remove();\n    };\n  }, [getNavigation]);\n\n  return focused;\n};\n"]},"metadata":{},"sourceType":"script"}